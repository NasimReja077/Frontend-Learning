## ğŸ§  **Redux Overview**

**Redux** is a **state management library** for JavaScript apps, commonly used with **React** to manage the appâ€™s data (state) in one central place (the **Store**).
It helps keep your app predictable, maintainable, and debuggable.

---

## ğŸ”¹ 1. **Store**

### ğŸ“˜ Definition:

The **Store** is the **single source of truth** in Redux.
It holds the **entire state tree** of your application.

### ğŸ“¦ Example:

```js
import { createStore } from 'redux';
import counterReducer from './counterReducer';

const store = createStore(counterReducer);
export default store;
```

* You can access state using `store.getState()`
* Update it using `store.dispatch(action)`
* Listen for changes using `store.subscribe(listener)`

---

## ğŸ”¹ 2. **State**

### ğŸ“˜ Definition:

The **State** is the **current data** or snapshot inside the Redux Store at a particular time.

* Example: if your app has a counter and user info:

```js
{
  counter: 5,
  user: { name: "Nasim", loggedIn: true }
}
```

You never modify the state directly â€” you send **actions** to **reducers** to get a new state.

---

## ğŸ”¹ 3. **Actions**

### ğŸ“˜ Definition:

An **Action** is a **plain JavaScript object** that tells Redux **what happened**.

It **must** have a `type` property (string), and optionally a `payload`.

### âš¡ Example:

```js
const increment = {
  type: "INCREMENT"
};

const addUser = {
  type: "ADD_USER",
  payload: { name: "Nasim", age: 23 }
};
```

Actions describe **â€œwhat to doâ€**, not **â€œhow to do itâ€**.

---

## ğŸ”¹ 4. **Reducers**

### ğŸ“˜ Definition:

A **Reducer** is a **pure function** that takes the **current state** and an **action**, then returns a **new state**.

**Syntax:**

```js
(state, action) => newState
```

### âš¡ Example:

```js
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    case "DECREMENT":
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};
```

Reducers must always:

* Be **pure** (no side effects)
* Never mutate state directly

---

## ğŸ”¹ 5. **Redux Logger**

### ğŸ“˜ Definition:

**Redux Logger** is a middleware that logs every **action** and the **state changes** in your console â€” useful for debugging.

### âš™ï¸ Setup:

```js
import { legacy_createStore, applyMiddleware } from "redux";
import logger from "redux-logger";
import rootReducer from "./reducers";

const store = legacy_createStore(rootReducer, applyMiddleware(logger));
```

### ğŸ§¾ Output Example:

```
prev state: { count: 0 }
action: { type: "INCREMENT" }
next state: { count: 1 }
```

---

## ğŸ”¹ 6. **Redux Thunk**

### ğŸ“˜ Definition:

**Redux Thunk** is middleware that lets you write **async actions** (like API calls).

Without it, Redux actions must be **synchronous**.

### âš™ï¸ Setup:

```js
import thunk from 'redux-thunk';
import { createStore, applyMiddleware } from 'redux';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(thunk));
```

### âš¡ Async Action Example:

```js
export const fetchUsers = () => {
  return async (dispatch) => {
    dispatch({ type: "FETCH_USERS_REQUEST" });
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    const data = await response.json();
    dispatch({ type: "FETCH_USERS_SUCCESS", payload: data });
  };
};
```

---

## ğŸ”¹ 7. **Action Creators**

### ğŸ“˜ Definition:

An **Action Creator** is a **function** that returns an **action** (object).

It helps avoid hardcoding action objects in components.

### âš¡ Example:

```js
export const increment = () => ({
  type: "INCREMENT"
});

export const addUser = (user) => ({
  type: "ADD_USER",
  payload: user
});
```

You can then dispatch them like:

```js
dispatch(increment());
dispatch(addUser({ name: "Nasim" }));
```

---

## ğŸ”¹ 8. **Combining Reducers**

### ğŸ“˜ Definition:

Large apps have multiple reducers â€” we use `combineReducers()` to merge them.

### âš¡ Example:

```js
import { combineReducers } from "redux";
import counterReducer from "./counterReducer";
import userReducer from "./userReducer";

const rootReducer = combineReducers({
  counter: counterReducer,
  user: userReducer
});

export default rootReducer;
```

Now the storeâ€™s state looks like:

```js
{
  counter: { count: 0 },
  user: { name: "Nasim" }
}
```

---

## ğŸ”¹ 9. **Immutability of State**

### ğŸ“˜ Definition:

In Redux, **state must never be changed directly**.
Instead, always **return a new copy**.

### âŒ Wrong:

```js
state.count += 1;
return state;
```

### âœ… Correct:

```js
return { ...state, count: state.count + 1 };
```

Immutability helps Redux **detect state changes** efficiently and keeps it predictable.

---

## ğŸ”¹ 10. **JSON Server and APIs**

### ğŸ“˜ Definition:

**JSON Server** is a tool to create a **fake REST API** using a simple JSON file â€” perfect for Redux testing with async data (Thunk).

### âš™ï¸ Setup:

1. Install:

```bash
npm install -g json-server
```

2. Create `db.json`:

```json
{
  "users": [
    { "id": 1, "name": "Nasim" },
    { "id": 2, "name": "Reja" }
  ]
}
```

3. Start Server:

```bash
json-server --watch db.json --port 5000
```

4. Example Fetch:

```js
export const fetchUsers = () => async (dispatch) => {
  const res = await fetch("http://localhost:5000/users");
  const data = await res.json();
  dispatch({ type: "SET_USERS", payload: data });
};
```

---

## ğŸ¯ **Summary Table**

| Concept              | Description                | Example                       |
| -------------------- | -------------------------- | ----------------------------- |
| **Store**            | Holds app state            | `createStore(rootReducer)`    |
| **State**            | Data inside Store          | `{count: 5}`                  |
| **Actions**          | Describe what happened     | `{type: "INCREMENT"}`         |
| **Reducers**         | Update state               | `switch(action.type)`         |
| **Logger**           | Logs actions/state         | `applyMiddleware(logger)`     |
| **Thunk**            | Async actions              | `dispatch(fetchData())`       |
| **Action Creators**  | Function returning actions | `addUser(user)`               |
| **Combine Reducers** | Merge multiple reducers    | `combineReducers({...})`      |
| **Immutability**     | Donâ€™t mutate state         | `return {...state}`           |
| **JSON Server**      | Mock backend               | `json-server --watch db.json` |

-----
------


## Pat-2

* **What it is**
* **Why it matters**
* **How it works (with code snippets)**
* **Key gotchas / best practices**

---

## 1. **Store**
```js
import { createStore, applyMiddleware } from 'redux';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(...));
```

| Aspect | Description |
|--------|-------------|
| **Definition** | The **single source of truth** â€“ a JavaScript object that holds the **entire application state**. |
| **Creation** | `createStore(reducer, [preloadedState], [enhancer])` (or `configureStore` in RTK). |
| **Methods** | `getState()`, `dispatch(action)`, `subscribe(listener)`, `replaceReducer()`. |
| **Why** | Guarantees **predictable state updates**; only one store per app. |
| **Best Practice** | Use **Redux Toolkit (RTK)** `configureStore` â€“ it auto-applies `thunk`, `devTools`, immutability checks. |

---

## 2. **State**
```js
store.getState();
// â†’ { todos: [...], visibilityFilter: 'SHOW_ALL' }
```

| Aspect | Description |
|--------|-------------|
| **Definition** | The **current snapshot** of data inside the store. |
| **Shape** | Plain JavaScript object (or array, primitive). |
| **Immutability** | **Never mutate directly** â€“ always return a **new object** in reducers. |
| **Why** | Enables time-travel debugging, change detection, memoization. |

---

## 3. **Actions**
```js
// Action object
{
  type: 'ADD_TODO',
  payload: { id: 1, text: 'Learn Redux' }
}
```

| Aspect | Description |
|--------|-------------|
| **Definition** | **Plain objects** that describe **â€œwhat happenedâ€**. Must have a `type` string. |
| **Convention** | `payload` (or `data`) holds additional info. |
| **Why** | The **only way** to trigger a state change. |
| **Best Practice** | Use **constants** for `type` (`export const ADD_TODO = 'ADD_TODO'`). |

---

## 4. **Reducers**
```js
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'TOGGLE_TODO':
      return state.map(t => 
        t.id === action.payload.id ? { ...t, completed: !t.completed } : t
      );
    default:
      return state;
  }
}
```

| Aspect | Description |
|--------|-------------|
| **Definition** | **Pure functions** `(state, action) => newState`. |
| **Rules** | 1. No side effects 2. No mutation 3. Same input â†’ same output. |
| **Why** | Guarantees **predictability** and **testability**. |
| **Best Practice** | Keep reducers **small**; split by domain (slice). Use RTK `createSlice`. |

---

## 5. **Redux Logger**
```js
import { createLogger } from 'redux-logger';
const logger = createLogger({ collapsed: true });
const store = createStore(rootReducer, applyMiddleware(logger));
```

| Aspect | Description |
|--------|-------------|
| **Purpose** | Logs **action â†’ old state â†’ new state** in the console. |
| **When to use** | **Development only** â€“ remove in production. |
| **Features** | Color-coded, diff view, collapsible groups. |
| **RTK** | `configureStore` includes it via `devTools: true` + `middleware: getDefaultMiddleware().concat(logger)`. |

---

## 6. **Redux Thunk**
```js
// Action creator returning a function
export const fetchTodos = () => async (dispatch) => {
  dispatch({ type: 'FETCH_TODOS_REQUEST' });
  try {
    const res = await fetch('/api/todos');
    const data = await res.json();
    dispatch({ type: 'FETCH_TODOS_SUCCESS', payload: data });
  } catch (err) {
    dispatch({ type: 'FETCH_TODOS_FAILURE', payload: err.message });
  }
};
```

| Aspect | Description |
|--------|-------------|
| **Definition** | Middleware that lets **action creators return a function** instead of an object. |
| **Signature** | `function(dispatch, getState) { â€¦ }` |
| **Why** | Enables **async logic** (API calls, timers). |
| **RTK Alternative** | `createAsyncThunk` (recommended). |

---

## 7. **Action Creators**
```js
// Simple
export const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: { id: Date.now(), text }
});

// Async (with thunk)
export const fetchUser = (id) => (dispatch) => {
  // fetch logicâ€¦
};
```

| Aspect | Description |
|--------|-------------|
| **Definition** | **Functions that return action objects** (or thunks). |
| **Why** | Encapsulate action creation â†’ cleaner components. |
| **RTK** | `createSlice` auto-generates them (`actions.addTodo`). |

---

## 8. **Combining Reducers**
```js
import { combineReducers } from 'redux';
import todos from './todos';
import visibilityFilter from './visibilityFilter';

const rootReducer = combineReducers({
  todos,
  visibilityFilter
});
```

| Aspect | Description |
|--------|-------------|
| **Purpose** | Merge **multiple slice reducers** into **one root reducer**. |
| **Resulting state** | `{ todos: ..., visibilityFilter: ... }` |
| **RTK** | `configureStore({ reducer: { todos, visibilityFilter } })` does the same. |

---

## 9. **Immutability of States**
```js
// WRONG
state.push(newItem);

// CORRECT
return [...state, newItem];

// Object spread
return { ...state, counter: state.counter + 1 };
```

| Rule | Example |
|------|---------|
| **Never mutate** | `state.prop = value` â†’ **NO** |
| **Always return new reference** | `[...state, newItem]`, `{...state, prop}` |
| **Deep updates** | Use `immer` (RTK includes it) or libraries like `immutable.js`. |

**Why?**  
- Enables **shallow equality checks** (`prevState === nextState`).  
- Powers **React-Redux `useSelector` memoization**.  
- Makes **time-travel debugging** possible.

---

## 10. **JSON Server & APIs (in Redux context)**
```bash
# Install & run a fake REST API
npm install -g json-server
json-server --watch db.json --port 4000
```

```js
// db.json
{
  "todos": [
    { "id": 1, "text": "Learn Redux", "completed": false }
  ]
}
```

### Using with Redux Thunk
```js
export const loadTodos = () => async (dispatch) => {
  const response = await fetch('http://localhost:4000/todos');
  const todos = await response.json();
  dispatch({ type: 'LOAD_TODOS', payload: todos });
};
```

| Use-case | Tool |
|----------|------|
| **Mock API** | `json-server` (CRUD + filtering) |
| **Real API** | `axios` / native `fetch` inside thunks |
| **Typed async** | RTK `createAsyncThunk` + `createEntityAdapter` |

---

## Quick Reference Cheat-Sheet

| Concept | Core Idea | Modern RTK Equivalent |
|---------|-----------|------------------------|
| Store | `createStore` | `configureStore` |
| Reducer | pure `(state,action)=>newState` | `createSlice` |
| Action Creator | function returning action | auto-generated in slice |
| Thunk | return function | `createAsyncThunk` |
| Combine Reducers | `combineReducers({a,b})` | pass object to `reducer:` |
| Logger | `redux-logger` | `devTools` + optional logger |
| Immutability | manual spreads | `immer` (built-in) |

---

## TL;DR Summary

1. **Store** = single state tree.  
2. **State** = immutable snapshot.  
3. **Actions** = `{type, payload}`.  
4. **Reducers** = pure functions that compute new state.  
5. **Action Creators** = factories for actions.  
6. **Combine Reducers** = merge slice reducers.  
7. **Redux Thunk** = async actions.  
8. **Redux Logger** = dev console logging.  
9. **Immutability** = never mutate, always return new objects.  
10. **JSON Server** = fake REST API for rapid prototyping.

---

**Pro Tip:** Start every new Redux project with **Redux Toolkit (RTK)** â€“ it bundles the above concepts into a **simpler, immutable-by-default** API.

```js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo(state, action) { state.push(action.payload); }, // immer makes it safe
  }
});

export const store = configureStore({
  reducer: { todos: todosSlice.reducer }
});
```
----------------
---------------
Here's a **complete, clear, and visual explanation** of **how Redux works**, including:

1. **Redux Working Principle (Step-by-Step)**
2. **Redux Data Flow Diagram (Text + ASCII + Mermaid)**
3. **Visual Diagram Explanation**
4. **Real Example Walkthrough**

---

## 1. **How Redux Works â€“ Step-by-Step**

| Step | What Happens | Who Does It |
|------|--------------|-------------|
| 1 | **User clicks a button** (e.g., "Add Todo") | React Component |
| 2 | **Action Creator is called** â†’ returns an **Action** | Developer-written function |
| 3 | **Action is dispatched** to the **Store** | `store.dispatch(action)` |
| 4 | **Store forwards Action to Root Reducer** | Redux Core |
| 5 | **Reducer computes new State** (immutably) | Pure function |
| 6 | **Store saves the new State** | Redux Core |
| 7 | **UI re-renders** (React detects state change via `useSelector`) | React-Redux |

> **Key Rule**: **Only `dispatch(action)` changes state**. No direct mutation.

---

## 2. **Redux Data Flow Diagram**

### **Text-Based Flow (Linear)**

```
[UI] 
  â†“ (user clicks)
[Action Creator] â†’ { type: 'ADD_TODO', payload: 'Learn Redux' }
  â†“
dispatch(action)
  â†“
[STORE]
  â†“
[Root Reducer] â†’ (state, action) â†’ newState
  â†“
[STORE updates state]
  â†“
[UI re-renders via useSelector]
```

---

### **ASCII Diagram**

```
+----------------+       dispatch()       +-----------------+
|   React UI     | ----------------------> |     STORE       |
| (Component)    |                         | (Holds State)   |
+----------------+                         +-----------------+
       â†‘                                          â†“
       |                                    [Root Reducer]
       |                                          â†“
       |                                    new State
       |                                          â†“
       |                                   +-----------------+
       |                                   |   REDUCERS      |
       |                                   | (Pure Functions)|
       |                                   +-----------------+
       |                                          â†‘
       |                                          |
       +------------------------------------------+
                     subscribe / useSelector
```

---

### **Mermaid.js Diagram (Copy-Paste Ready)**

```mermaid
flowchart TD
    A[User Clicks Button<br/>(React Component)] 
    --> B[Action Creator<br/>addTodo('Learn Redux')]
    B --> C{Action Object<br/>{type: 'ADD_TODO', payload: 'Learn Redux'}}
    C --> D[dispatch(action)]
    D --> E[STORE]
    E --> F[Root Reducer<br/>combines all reducers]
    F --> G[todosReducer<br/>returns [...state, newTodo]]
    G --> H[New State Tree]
    H --> I[STORE saves newState]
    I --> J[React re-renders<br/>useSelector detects change]
    J --> A

    style E fill:#4CAF50,stroke:#333,color:white
    style F fill:#2196F3,stroke:#333,color:white
    style H fill:#FF9800,stroke:#333,color:white
```

> **Paste this into [mermaid.live](https://mermaid.live) to see interactive diagram**

---

## 3. **Visual Breakdown of the Diagram**

| Part | Meaning |
|------|--------|
| **UI â†’ Action Creator** | User interaction triggers a function |
| **Action Creator â†’ Action** | Returns a plain object |
| **dispatch() â†’ Store** | Only way to send action |
| **Store â†’ Reducer** | Reducer decides how state changes |
| **Reducer â†’ New State** | **Never mutates old state** |
| **Store â† New State** | Store replaces old state |
| **Store â†’ UI** | Components re-render if subscribed part changed |

---

## 4. **Real Example: Adding a Todo**

```js
// 1. Action Creator
export const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: { id: Date.now(), text, completed: false }
});

// 2. Reducer
const todosReducer = (state = [], action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload]; // new array!
    default:
      return state;
  }
};

// 3. Component
function TodoApp() {
  const dispatch = useDispatch();
  const todos = useSelector(state => state.todos);

  return (
    <div>
      <button onClick={() => dispatch(addTodo('Learn Redux'))}>
        Add Todo
      </button>
      <ul>
        {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}
      </ul>
    </div>
  );
}
```

### What Happens When Button is Clicked?

| Step | Code / Event |
|------|-------------|
| 1 | `onClick` â†’ `dispatch(addTodo('Learn Redux'))` |
| 2 | `addTodo()` returns action object |
| 3 | `dispatch()` sends to store |
| 4 | `todosReducer` runs â†’ returns `[..., newTodo]` |
| 5 | Store updates state |
| 6 | `useSelector` sees new `todos` â†’ component re-renders |

---

## 5. **Unidirectional Data Flow (Core Principle)**

```
UI â†’ Action â†’ Reducer â†’ State â†’ UI
       â†‘                             â†“
       +-----------------------------+
               One Direction Only
```

> **No loops, no side effects, fully predictable**

---

## 6. **With Middleware (e.g., Thunk, Logger)**

```
UI â†’ Action Creator (returns function) 
     â†’ Thunk Middleware â†’ async logic (fetch)
     â†’ dispatch(success action)
     â†’ Reducer â†’ State â†’ UI
```


```mermaid
flowchart LR
    A[UI] --> B[Thunk Action Creator]
    B --> C[Returns Function]
    C --> D[Redux Thunk Middleware]
    D --> E[API Call]
    E --> F[dispatch: SUCCESS]
    F --> G[Reducer]
    G --> H[New State]
    H --> I[UI Updates]
```

---

## Summary: Redux Data Flow in One Sentence

> **"User triggers â†’ Action Creator â†’ dispatch(action) â†’ Store calls Reducer â†’ New State â†’ UI re-renders"**

---

## Bonus: Common Interview Question

> **Q: Explain Redux data flow with a diagram.**

**Answer:**

```
1. User clicks â†’ Component calls dispatch(addTodo('Hi'))
2. dispatch() sends action to Store
3. Store runs rootReducer(oldState, action)
4. Reducer returns newState (immutable)
5. Store saves newState
6. useSelector() detects change â†’ Component re-renders
```

*(Draw the Mermaid diagram above on whiteboard)*

---
----


Perfect âœ… â€” letâ€™s now understand **how Redux actually works**, step by step â€”
like what happens **behind the scenes** when your React app updates data using **Redux**.

---

# âš™ï¸ **Redux Working Explained (Step-by-Step Flow)**

Letâ€™s imagine a **React + Redux Counter App** ğŸ”¢
You have a button â†’ when you click it â†’ the counter increases.

Weâ€™ll see what happens **inside Redux**.

---

## ğŸ§© Step 1: The Redux Store â€” â€œSingle Source of Truthâ€

Redux keeps **all app data (state)** inside one **Store**.

```js
const store = createStore(counterReducer);
```

Think of it like:

> A big box ğŸ—ƒï¸ holding the entire state tree of your app.

Example state:

```js
{
  count: 0,
  user: { name: "Nasim" }
}
```

---

## ğŸ§© Step 2: UI (React Component) Dispatches an Action

When a user clicks a button, we **dispatch** an **action**.

```js
// Counter.js
<button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
```

ğŸ‘‰ â€œDispatchâ€ means **sending a message** to Redux saying **what happened**.

---

## ğŸ§© Step 3: Action â€” â€œWhat happened?â€

An **action** is just a plain object.

Example:

```js
{
  type: "INCREMENT"
}
```

* `type` â†’ required key that describes the event
* `payload` â†’ optional data (e.g. `{ amount: 5 }`)

So, it tells Redux:

> â€œHey, increase the count!â€

---

## ğŸ§© Step 4: Reducer â€” â€œHow should state change?â€

Redux passes that **action** to the **reducer function**.

```js
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    case "DECREMENT":
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};
```

Reducer receives:

* Current `state`
* Dispatched `action`

Then it **returns a new state** (not modify the old one).

---

## ğŸ§© Step 5: Store Updates the State

Redux Store takes the **new state** from the reducer
and **replaces the old state** with it.

Internally:

* Redux saves `{ count: 1 }` (updated state)
* Redux tells all subscribers: â€œHey, state has changed!â€

---

## ğŸ§© Step 6: React Component Re-Renders

React components are connected to Redux store using `useSelector` (or `connect`).

```js
const count = useSelector((state) => state.count);
```

When Redux state updates:

* React automatically re-renders the component with the new data.

So now the UI shows:

```
Count: 1
```

---

## ğŸ§© Step 7: Optional Middleware (Logger / Thunk)

Middleware sits **between dispatching an action** and **reaching the reducer**.

### ğŸ”¹ Logger:

Logs the action & state changes in console.

```
prev state: { count: 0 }
action: { type: "INCREMENT" }
next state: { count: 1 }
```

### ğŸ”¹ Thunk:

Allows **async actions** (e.g. fetching API data).

Instead of returning an object, you return a **function** that performs async work and dispatches actions later.

```js
export const fetchUser = () => {
  return async (dispatch) => {
    const res = await fetch("/api/users");
    const data = await res.json();
    dispatch({ type: "SET_USERS", payload: data });
  };
};
```

---

## ğŸ§© Step 8: UI Updates Reactively

When new data (from reducer) updates the store:

* React automatically gets the new data via `useSelector`
* The UI re-renders with the updated state

Thatâ€™s why Redux ensures:

> The UI is always in sync with the state.

---

# ğŸ”„ **Redux Data Flow Diagram**

```
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚        React UI (View)       â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ dispatch(action)
                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚     ACTION      â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚    REDUCER      â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ returns new state
                     â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚     STORE       â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ notifies
                     â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚        React UI Updates      â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸ’¡ In Short:

| Step | Concept          | What Happens             |
| ---- | ---------------- | ------------------------ |
| 1    | **Store**        | Holds the global state   |
| 2    | **Dispatch**     | UI sends an action       |
| 3    | **Action**       | Describes what to do     |
| 4    | **Reducer**      | Computes new state       |
| 5    | **Store Update** | Saves new state          |
| 6    | **React**        | Auto re-renders UI       |
| 7    | **Middleware**   | Handles logging or async |
| 8    | **UI Sync**      | New state â†’ Updated UI   |

---

## ğŸ” Example Summary

### Before Click:

State â†’ `{ count: 0 }`

### After Dispatch:

`dispatch({ type: "INCREMENT" })`

### Reducer Runs â†’ New State:

`{ count: 1 }`

### UI Re-Renders:

```
Count: 1 âœ…
```

---
