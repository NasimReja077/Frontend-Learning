## 🧠 **Redux Overview**

**Redux** is a **state management library** for JavaScript apps, commonly used with **React** to manage the app’s data (state) in one central place (the **Store**).
It helps keep your app predictable, maintainable, and debuggable.

---

## 🔹 1. **Store**

### 📘 Definition:

The **Store** is the **single source of truth** in Redux.
It holds the **entire state tree** of your application.

### 📦 Example:

```js
import { createStore } from 'redux';
import counterReducer from './counterReducer';

const store = createStore(counterReducer);
export default store;
```

* You can access state using `store.getState()`
* Update it using `store.dispatch(action)`
* Listen for changes using `store.subscribe(listener)`

---

## 🔹 2. **State**

### 📘 Definition:

The **State** is the **current data** or snapshot inside the Redux Store at a particular time.

* Example: if your app has a counter and user info:

```js
{
  counter: 5,
  user: { name: "Nasim", loggedIn: true }
}
```

You never modify the state directly — you send **actions** to **reducers** to get a new state.

---

## 🔹 3. **Actions**

### 📘 Definition:

An **Action** is a **plain JavaScript object** that tells Redux **what happened**.

It **must** have a `type` property (string), and optionally a `payload`.

### ⚡ Example:

```js
const increment = {
  type: "INCREMENT"
};

const addUser = {
  type: "ADD_USER",
  payload: { name: "Nasim", age: 23 }
};
```

Actions describe **“what to do”**, not **“how to do it”**.

---

## 🔹 4. **Reducers**

### 📘 Definition:

A **Reducer** is a **pure function** that takes the **current state** and an **action**, then returns a **new state**.

**Syntax:**

```js
(state, action) => newState
```

### ⚡ Example:

```js
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    case "DECREMENT":
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};
```

Reducers must always:

* Be **pure** (no side effects)
* Never mutate state directly

---

## 🔹 5. **Redux Logger**

### 📘 Definition:

**Redux Logger** is a middleware that logs every **action** and the **state changes** in your console — useful for debugging.

### ⚙️ Setup:

```js
import { legacy_createStore, applyMiddleware } from "redux";
import logger from "redux-logger";
import rootReducer from "./reducers";

const store = legacy_createStore(rootReducer, applyMiddleware(logger));
```

### 🧾 Output Example:

```
prev state: { count: 0 }
action: { type: "INCREMENT" }
next state: { count: 1 }
```

---

## 🔹 6. **Redux Thunk**

### 📘 Definition:

**Redux Thunk** is middleware that lets you write **async actions** (like API calls).

Without it, Redux actions must be **synchronous**.

### ⚙️ Setup:

```js
import thunk from 'redux-thunk';
import { createStore, applyMiddleware } from 'redux';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(thunk));
```

### ⚡ Async Action Example:

```js
export const fetchUsers = () => {
  return async (dispatch) => {
    dispatch({ type: "FETCH_USERS_REQUEST" });
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    const data = await response.json();
    dispatch({ type: "FETCH_USERS_SUCCESS", payload: data });
  };
};
```

---

## 🔹 7. **Action Creators**

### 📘 Definition:

An **Action Creator** is a **function** that returns an **action** (object).

It helps avoid hardcoding action objects in components.

### ⚡ Example:

```js
export const increment = () => ({
  type: "INCREMENT"
});

export const addUser = (user) => ({
  type: "ADD_USER",
  payload: user
});
```

You can then dispatch them like:

```js
dispatch(increment());
dispatch(addUser({ name: "Nasim" }));
```

---

## 🔹 8. **Combining Reducers**

### 📘 Definition:

Large apps have multiple reducers — we use `combineReducers()` to merge them.

### ⚡ Example:

```js
import { combineReducers } from "redux";
import counterReducer from "./counterReducer";
import userReducer from "./userReducer";

const rootReducer = combineReducers({
  counter: counterReducer,
  user: userReducer
});

export default rootReducer;
```

Now the store’s state looks like:

```js
{
  counter: { count: 0 },
  user: { name: "Nasim" }
}
```

---

## 🔹 9. **Immutability of State**

### 📘 Definition:

In Redux, **state must never be changed directly**.
Instead, always **return a new copy**.

### ❌ Wrong:

```js
state.count += 1;
return state;
```

### ✅ Correct:

```js
return { ...state, count: state.count + 1 };
```

Immutability helps Redux **detect state changes** efficiently and keeps it predictable.

---

## 🔹 10. **JSON Server and APIs**

### 📘 Definition:

**JSON Server** is a tool to create a **fake REST API** using a simple JSON file — perfect for Redux testing with async data (Thunk).

### ⚙️ Setup:

1. Install:

```bash
npm install -g json-server
```

2. Create `db.json`:

```json
{
  "users": [
    { "id": 1, "name": "Nasim" },
    { "id": 2, "name": "Reja" }
  ]
}
```

3. Start Server:

```bash
json-server --watch db.json --port 5000
```

4. Example Fetch:

```js
export const fetchUsers = () => async (dispatch) => {
  const res = await fetch("http://localhost:5000/users");
  const data = await res.json();
  dispatch({ type: "SET_USERS", payload: data });
};
```

---

## 🎯 **Summary Table**

| Concept              | Description                | Example                       |
| -------------------- | -------------------------- | ----------------------------- |
| **Store**            | Holds app state            | `createStore(rootReducer)`    |
| **State**            | Data inside Store          | `{count: 5}`                  |
| **Actions**          | Describe what happened     | `{type: "INCREMENT"}`         |
| **Reducers**         | Update state               | `switch(action.type)`         |
| **Logger**           | Logs actions/state         | `applyMiddleware(logger)`     |
| **Thunk**            | Async actions              | `dispatch(fetchData())`       |
| **Action Creators**  | Function returning actions | `addUser(user)`               |
| **Combine Reducers** | Merge multiple reducers    | `combineReducers({...})`      |
| **Immutability**     | Don’t mutate state         | `return {...state}`           |
| **JSON Server**      | Mock backend               | `json-server --watch db.json` |

-----
------


## Pat-2

* **What it is**
* **Why it matters**
* **How it works (with code snippets)**
* **Key gotchas / best practices**

---

## 1. **Store**
```js
import { createStore, applyMiddleware } from 'redux';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(...));
```

| Aspect | Description |
|--------|-------------|
| **Definition** | The **single source of truth** – a JavaScript object that holds the **entire application state**. |
| **Creation** | `createStore(reducer, [preloadedState], [enhancer])` (or `configureStore` in RTK). |
| **Methods** | `getState()`, `dispatch(action)`, `subscribe(listener)`, `replaceReducer()`. |
| **Why** | Guarantees **predictable state updates**; only one store per app. |
| **Best Practice** | Use **Redux Toolkit (RTK)** `configureStore` – it auto-applies `thunk`, `devTools`, immutability checks. |

---

## 2. **State**
```js
store.getState();
// → { todos: [...], visibilityFilter: 'SHOW_ALL' }
```

| Aspect | Description |
|--------|-------------|
| **Definition** | The **current snapshot** of data inside the store. |
| **Shape** | Plain JavaScript object (or array, primitive). |
| **Immutability** | **Never mutate directly** – always return a **new object** in reducers. |
| **Why** | Enables time-travel debugging, change detection, memoization. |

---

## 3. **Actions**
```js
// Action object
{
  type: 'ADD_TODO',
  payload: { id: 1, text: 'Learn Redux' }
}
```

| Aspect | Description |
|--------|-------------|
| **Definition** | **Plain objects** that describe **“what happened”**. Must have a `type` string. |
| **Convention** | `payload` (or `data`) holds additional info. |
| **Why** | The **only way** to trigger a state change. |
| **Best Practice** | Use **constants** for `type` (`export const ADD_TODO = 'ADD_TODO'`). |

---

## 4. **Reducers**
```js
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'TOGGLE_TODO':
      return state.map(t => 
        t.id === action.payload.id ? { ...t, completed: !t.completed } : t
      );
    default:
      return state;
  }
}
```

| Aspect | Description |
|--------|-------------|
| **Definition** | **Pure functions** `(state, action) => newState`. |
| **Rules** | 1. No side effects 2. No mutation 3. Same input → same output. |
| **Why** | Guarantees **predictability** and **testability**. |
| **Best Practice** | Keep reducers **small**; split by domain (slice). Use RTK `createSlice`. |

---

## 5. **Redux Logger**
```js
import { createLogger } from 'redux-logger';
const logger = createLogger({ collapsed: true });
const store = createStore(rootReducer, applyMiddleware(logger));
```

| Aspect | Description |
|--------|-------------|
| **Purpose** | Logs **action → old state → new state** in the console. |
| **When to use** | **Development only** – remove in production. |
| **Features** | Color-coded, diff view, collapsible groups. |
| **RTK** | `configureStore` includes it via `devTools: true` + `middleware: getDefaultMiddleware().concat(logger)`. |

---

## 6. **Redux Thunk**
```js
// Action creator returning a function
export const fetchTodos = () => async (dispatch) => {
  dispatch({ type: 'FETCH_TODOS_REQUEST' });
  try {
    const res = await fetch('/api/todos');
    const data = await res.json();
    dispatch({ type: 'FETCH_TODOS_SUCCESS', payload: data });
  } catch (err) {
    dispatch({ type: 'FETCH_TODOS_FAILURE', payload: err.message });
  }
};
```

| Aspect | Description |
|--------|-------------|
| **Definition** | Middleware that lets **action creators return a function** instead of an object. |
| **Signature** | `function(dispatch, getState) { … }` |
| **Why** | Enables **async logic** (API calls, timers). |
| **RTK Alternative** | `createAsyncThunk` (recommended). |

---

## 7. **Action Creators**
```js
// Simple
export const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: { id: Date.now(), text }
});

// Async (with thunk)
export const fetchUser = (id) => (dispatch) => {
  // fetch logic…
};
```

| Aspect | Description |
|--------|-------------|
| **Definition** | **Functions that return action objects** (or thunks). |
| **Why** | Encapsulate action creation → cleaner components. |
| **RTK** | `createSlice` auto-generates them (`actions.addTodo`). |

---

## 8. **Combining Reducers**
```js
import { combineReducers } from 'redux';
import todos from './todos';
import visibilityFilter from './visibilityFilter';

const rootReducer = combineReducers({
  todos,
  visibilityFilter
});
```

| Aspect | Description |
|--------|-------------|
| **Purpose** | Merge **multiple slice reducers** into **one root reducer**. |
| **Resulting state** | `{ todos: ..., visibilityFilter: ... }` |
| **RTK** | `configureStore({ reducer: { todos, visibilityFilter } })` does the same. |

---

## 9. **Immutability of States**
```js
// WRONG
state.push(newItem);

// CORRECT
return [...state, newItem];

// Object spread
return { ...state, counter: state.counter + 1 };
```

| Rule | Example |
|------|---------|
| **Never mutate** | `state.prop = value` → **NO** |
| **Always return new reference** | `[...state, newItem]`, `{...state, prop}` |
| **Deep updates** | Use `immer` (RTK includes it) or libraries like `immutable.js`. |

**Why?**  
- Enables **shallow equality checks** (`prevState === nextState`).  
- Powers **React-Redux `useSelector` memoization**.  
- Makes **time-travel debugging** possible.

---

## 10. **JSON Server & APIs (in Redux context)**
```bash
# Install & run a fake REST API
npm install -g json-server
json-server --watch db.json --port 4000
```

```js
// db.json
{
  "todos": [
    { "id": 1, "text": "Learn Redux", "completed": false }
  ]
}
```

### Using with Redux Thunk
```js
export const loadTodos = () => async (dispatch) => {
  const response = await fetch('http://localhost:4000/todos');
  const todos = await response.json();
  dispatch({ type: 'LOAD_TODOS', payload: todos });
};
```

| Use-case | Tool |
|----------|------|
| **Mock API** | `json-server` (CRUD + filtering) |
| **Real API** | `axios` / native `fetch` inside thunks |
| **Typed async** | RTK `createAsyncThunk` + `createEntityAdapter` |

---

## Quick Reference Cheat-Sheet

| Concept | Core Idea | Modern RTK Equivalent |
|---------|-----------|------------------------|
| Store | `createStore` | `configureStore` |
| Reducer | pure `(state,action)=>newState` | `createSlice` |
| Action Creator | function returning action | auto-generated in slice |
| Thunk | return function | `createAsyncThunk` |
| Combine Reducers | `combineReducers({a,b})` | pass object to `reducer:` |
| Logger | `redux-logger` | `devTools` + optional logger |
| Immutability | manual spreads | `immer` (built-in) |

---

## TL;DR Summary

1. **Store** = single state tree.  
2. **State** = immutable snapshot.  
3. **Actions** = `{type, payload}`.  
4. **Reducers** = pure functions that compute new state.  
5. **Action Creators** = factories for actions.  
6. **Combine Reducers** = merge slice reducers.  
7. **Redux Thunk** = async actions.  
8. **Redux Logger** = dev console logging.  
9. **Immutability** = never mutate, always return new objects.  
10. **JSON Server** = fake REST API for rapid prototyping.

---

**Pro Tip:** Start every new Redux project with **Redux Toolkit (RTK)** – it bundles the above concepts into a **simpler, immutable-by-default** API.

```js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo(state, action) { state.push(action.payload); }, // immer makes it safe
  }
});

export const store = configureStore({
  reducer: { todos: todosSlice.reducer }
});
```
----------------
---------------
Here's a **complete, clear, and visual explanation** of **how Redux works**, including:

1. **Redux Working Principle (Step-by-Step)**
2. **Redux Data Flow Diagram (Text + ASCII + Mermaid)**
3. **Visual Diagram Explanation**
4. **Real Example Walkthrough**

---

## 1. **How Redux Works – Step-by-Step**

| Step | What Happens | Who Does It |
|------|--------------|-------------|
| 1 | **User clicks a button** (e.g., "Add Todo") | React Component |
| 2 | **Action Creator is called** → returns an **Action** | Developer-written function |
| 3 | **Action is dispatched** to the **Store** | `store.dispatch(action)` |
| 4 | **Store forwards Action to Root Reducer** | Redux Core |
| 5 | **Reducer computes new State** (immutably) | Pure function |
| 6 | **Store saves the new State** | Redux Core |
| 7 | **UI re-renders** (React detects state change via `useSelector`) | React-Redux |

> **Key Rule**: **Only `dispatch(action)` changes state**. No direct mutation.

---

## 2. **Redux Data Flow Diagram**

### **Text-Based Flow (Linear)**

```
[UI] 
  ↓ (user clicks)
[Action Creator] → { type: 'ADD_TODO', payload: 'Learn Redux' }
  ↓
dispatch(action)
  ↓
[STORE]
  ↓
[Root Reducer] → (state, action) → newState
  ↓
[STORE updates state]
  ↓
[UI re-renders via useSelector]
```

---

### **ASCII Diagram**

```
+----------------+       dispatch()       +-----------------+
|   React UI     | ----------------------> |     STORE       |
| (Component)    |                         | (Holds State)   |
+----------------+                         +-----------------+
       ↑                                          ↓
       |                                    [Root Reducer]
       |                                          ↓
       |                                    new State
       |                                          ↓
       |                                   +-----------------+
       |                                   |   REDUCERS      |
       |                                   | (Pure Functions)|
       |                                   +-----------------+
       |                                          ↑
       |                                          |
       +------------------------------------------+
                     subscribe / useSelector
```

---

### **Mermaid.js Diagram (Copy-Paste Ready)**

```mermaid
flowchart TD
    A[User Clicks Button<br/>(React Component)] 
    --> B[Action Creator<br/>addTodo('Learn Redux')]
    B --> C{Action Object<br/>{type: 'ADD_TODO', payload: 'Learn Redux'}}
    C --> D[dispatch(action)]
    D --> E[STORE]
    E --> F[Root Reducer<br/>combines all reducers]
    F --> G[todosReducer<br/>returns [...state, newTodo]]
    G --> H[New State Tree]
    H --> I[STORE saves newState]
    I --> J[React re-renders<br/>useSelector detects change]
    J --> A

    style E fill:#4CAF50,stroke:#333,color:white
    style F fill:#2196F3,stroke:#333,color:white
    style H fill:#FF9800,stroke:#333,color:white
```

> **Paste this into [mermaid.live](https://mermaid.live) to see interactive diagram**

---

## 3. **Visual Breakdown of the Diagram**

| Part | Meaning |
|------|--------|
| **UI → Action Creator** | User interaction triggers a function |
| **Action Creator → Action** | Returns a plain object |
| **dispatch() → Store** | Only way to send action |
| **Store → Reducer** | Reducer decides how state changes |
| **Reducer → New State** | **Never mutates old state** |
| **Store ← New State** | Store replaces old state |
| **Store → UI** | Components re-render if subscribed part changed |

---

## 4. **Real Example: Adding a Todo**

```js
// 1. Action Creator
export const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: { id: Date.now(), text, completed: false }
});

// 2. Reducer
const todosReducer = (state = [], action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload]; // new array!
    default:
      return state;
  }
};

// 3. Component
function TodoApp() {
  const dispatch = useDispatch();
  const todos = useSelector(state => state.todos);

  return (
    <div>
      <button onClick={() => dispatch(addTodo('Learn Redux'))}>
        Add Todo
      </button>
      <ul>
        {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}
      </ul>
    </div>
  );
}
```

### What Happens When Button is Clicked?

| Step | Code / Event |
|------|-------------|
| 1 | `onClick` → `dispatch(addTodo('Learn Redux'))` |
| 2 | `addTodo()` returns action object |
| 3 | `dispatch()` sends to store |
| 4 | `todosReducer` runs → returns `[..., newTodo]` |
| 5 | Store updates state |
| 6 | `useSelector` sees new `todos` → component re-renders |

---

## 5. **Unidirectional Data Flow (Core Principle)**

```
UI → Action → Reducer → State → UI
       ↑                             ↓
       +-----------------------------+
               One Direction Only
```

> **No loops, no side effects, fully predictable**

---

## 6. **With Middleware (e.g., Thunk, Logger)**

```
UI → Action Creator (returns function) 
     → Thunk Middleware → async logic (fetch)
     → dispatch(success action)
     → Reducer → State → UI
```


```mermaid
flowchart LR
    A[UI] --> B[Thunk Action Creator]
    B --> C[Returns Function]
    C --> D[Redux Thunk Middleware]
    D --> E[API Call]
    E --> F[dispatch: SUCCESS]
    F --> G[Reducer]
    G --> H[New State]
    H --> I[UI Updates]
```

---

## Summary: Redux Data Flow in One Sentence

> **"User triggers → Action Creator → dispatch(action) → Store calls Reducer → New State → UI re-renders"**

---

## Bonus: Common Interview Question

> **Q: Explain Redux data flow with a diagram.**

**Answer:**

```
1. User clicks → Component calls dispatch(addTodo('Hi'))
2. dispatch() sends action to Store
3. Store runs rootReducer(oldState, action)
4. Reducer returns newState (immutable)
5. Store saves newState
6. useSelector() detects change → Component re-renders
```

*(Draw the Mermaid diagram above on whiteboard)*

---
----


Perfect ✅ — let’s now understand **how Redux actually works**, step by step —
like what happens **behind the scenes** when your React app updates data using **Redux**.

---

# ⚙️ **Redux Working Explained (Step-by-Step Flow)**

Let’s imagine a **React + Redux Counter App** 🔢
You have a button → when you click it → the counter increases.

We’ll see what happens **inside Redux**.

---

## 🧩 Step 1: The Redux Store — “Single Source of Truth”

Redux keeps **all app data (state)** inside one **Store**.

```js
const store = createStore(counterReducer);
```

Think of it like:

> A big box 🗃️ holding the entire state tree of your app.

Example state:

```js
{
  count: 0,
  user: { name: "Nasim" }
}
```

---

## 🧩 Step 2: UI (React Component) Dispatches an Action

When a user clicks a button, we **dispatch** an **action**.

```js
// Counter.js
<button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
```

👉 “Dispatch” means **sending a message** to Redux saying **what happened**.

---

## 🧩 Step 3: Action — “What happened?”

An **action** is just a plain object.

Example:

```js
{
  type: "INCREMENT"
}
```

* `type` → required key that describes the event
* `payload` → optional data (e.g. `{ amount: 5 }`)

So, it tells Redux:

> “Hey, increase the count!”

---

## 🧩 Step 4: Reducer — “How should state change?”

Redux passes that **action** to the **reducer function**.

```js
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    case "DECREMENT":
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};
```

Reducer receives:

* Current `state`
* Dispatched `action`

Then it **returns a new state** (not modify the old one).

---

## 🧩 Step 5: Store Updates the State

Redux Store takes the **new state** from the reducer
and **replaces the old state** with it.

Internally:

* Redux saves `{ count: 1 }` (updated state)
* Redux tells all subscribers: “Hey, state has changed!”

---

## 🧩 Step 6: React Component Re-Renders

React components are connected to Redux store using `useSelector` (or `connect`).

```js
const count = useSelector((state) => state.count);
```

When Redux state updates:

* React automatically re-renders the component with the new data.

So now the UI shows:

```
Count: 1
```

---

## 🧩 Step 7: Optional Middleware (Logger / Thunk)

Middleware sits **between dispatching an action** and **reaching the reducer**.

### 🔹 Logger:

Logs the action & state changes in console.

```
prev state: { count: 0 }
action: { type: "INCREMENT" }
next state: { count: 1 }
```

### 🔹 Thunk:

Allows **async actions** (e.g. fetching API data).

Instead of returning an object, you return a **function** that performs async work and dispatches actions later.

```js
export const fetchUser = () => {
  return async (dispatch) => {
    const res = await fetch("/api/users");
    const data = await res.json();
    dispatch({ type: "SET_USERS", payload: data });
  };
};
```

---

## 🧩 Step 8: UI Updates Reactively

When new data (from reducer) updates the store:

* React automatically gets the new data via `useSelector`
* The UI re-renders with the updated state

That’s why Redux ensures:

> The UI is always in sync with the state.

---

# 🔄 **Redux Data Flow Diagram**

```
       ┌──────────────────────────────┐
       │        React UI (View)       │
       └──────────────┬───────────────┘
                      │ dispatch(action)
                      ▼
              ┌─────────────────┐
              │     ACTION      │
              └──────┬──────────┘
                     │
                     ▼
              ┌─────────────────┐
              │    REDUCER      │
              └──────┬──────────┘
                     │ returns new state
                     ▼
              ┌─────────────────┐
              │     STORE       │
              └──────┬──────────┘
                     │ notifies
                     ▼
       ┌──────────────────────────────┐
       │        React UI Updates      │
       └──────────────────────────────┘
```

---

# 💡 In Short:

| Step | Concept          | What Happens             |
| ---- | ---------------- | ------------------------ |
| 1    | **Store**        | Holds the global state   |
| 2    | **Dispatch**     | UI sends an action       |
| 3    | **Action**       | Describes what to do     |
| 4    | **Reducer**      | Computes new state       |
| 5    | **Store Update** | Saves new state          |
| 6    | **React**        | Auto re-renders UI       |
| 7    | **Middleware**   | Handles logging or async |
| 8    | **UI Sync**      | New state → Updated UI   |

---

## 🔁 Example Summary

### Before Click:

State → `{ count: 0 }`

### After Dispatch:

`dispatch({ type: "INCREMENT" })`

### Reducer Runs → New State:

`{ count: 1 }`

### UI Re-Renders:

```
Count: 1 ✅
```

---
